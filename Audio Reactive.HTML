<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Audio Reactive Neon Grid</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #02030a;
      --accent1: #33ffcc;
      --accent2: #ff2a6d;
      --accent3: #6d5dff;
    }

    body {
      background: radial-gradient(circle at top, #0b1020 0, #02030a 55%, #000 100%);
      color: #f5f5f5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .wrap {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    header {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
      z-index: 5;
    }

    header h1 {
      font-size: 14px;
      letter-spacing: 0.35em;
      text-transform: uppercase;
      color: #b7b9ff;
      opacity: 0.75;
      text-shadow: 0 0 12px rgba(109, 93, 255, 0.8);
    }

    header h1 span {
      color: var(--accent1);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      grid-template-rows: minmax(0, 1fr) auto;
    }

    .scene {
      position: relative;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      filter: drop-shadow(0 0 18px rgba(0, 255, 170, 0.45));
    }

    .controls {
      position: relative;
      padding: 16px 24px 22px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.92), transparent);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(22px);
      -webkit-backdrop-filter: blur(22px);
    }

    .left {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .glow-dot {
      width: 11px;
      height: 11px;
      border-radius: 999px;
      background: radial-gradient(circle, var(--accent1), #006b4e 60%, transparent 70%);
      box-shadow:
        0 0 6px rgba(51, 255, 204, 0.7),
        0 0 32px rgba(51, 255, 204, 0.8);
      position: relative;
    }

    .glow-dot::after {
      content: "";
      position: absolute;
      inset: -4px;
      border-radius: inherit;
      border: 1px solid rgba(51, 255, 204, 0.35);
      opacity: 0.7;
    }

    .indicator-text {
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(240, 248, 255, 0.8);
      opacity: 0.8;
    }

    .indicator-text span {
      color: var(--accent1);
    }

    .button-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .btn {
      position: relative;
      border: none;
      border-radius: 999px;
      padding: 10px 20px;
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      cursor: pointer;
      background: radial-gradient(
          circle at top left,
          rgba(51, 255, 204, 0.16),
          transparent 55%
        ),
        radial-gradient(circle at bottom right, rgba(255, 42, 109, 0.22), transparent 60%),
        rgba(7, 10, 28, 0.96);
      color: #eaf6ff;
      border: 1px solid rgba(134, 149, 255, 0.5);
      box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.9),
        0 0 18px rgba(0, 0, 0, 0.9);
      display: inline-flex;
      align-items: center;
      gap: 10px;
      overflow: hidden;
    }

    .btn::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        120deg,
        rgba(51, 255, 204, 0) 0%,
        rgba(51, 255, 204, 0.35) 40%,
        rgba(109, 93, 255, 0.45) 60%,
        rgba(255, 42, 109, 0.2) 100%
      );
      opacity: 0;
      transition: opacity 260ms ease-out;
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .btn:hover::before {
      opacity: 1;
    }

    .btn span.dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: radial-gradient(circle, var(--accent2), transparent 70%);
      box-shadow:
        0 0 8px rgba(255, 42, 109, 0.9),
        0 0 24px rgba(255, 42, 109, 0.7);
    }

    .btn span.txt {
      font-weight: 500;
      opacity: 0.92;
    }

    .modes {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: rgba(200, 210, 255, 0.76);
    }

    .mode-pill {
      border-radius: 999px;
      border: 1px solid rgba(120, 132, 255, 0.6);
      padding: 4px 8px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 9px;
      opacity: 0.85;
      cursor: pointer;
      background: linear-gradient(
        to right,
        rgba(12, 18, 52, 0.92),
        rgba(18, 12, 52, 0.92)
      );
    }

    .mode-pill.active {
      border-color: var(--accent1);
      color: var(--accent1);
      box-shadow: 0 0 16px rgba(51, 255, 204, 0.4);
      background: radial-gradient(circle at top, rgba(51, 255, 204, 0.2), transparent 70%);
    }

    .right {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .tiny-label {
      font-size: 9px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      opacity: 0.6;
      color: #f0f4ff;
    }

    .bar {
      position: relative;
      width: 120px;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(
        to right,
        rgba(51, 255, 204, 0.18),
        rgba(109, 93, 255, 0.08),
        rgba(255, 42, 109, 0.12)
      );
      overflow: hidden;
    }

    .bar-fill {
      position: absolute;
      inset: 0;
      width: 24%;
      border-radius: inherit;
      background: linear-gradient(
        90deg,
        #33ffcc,
        #6d5dff,
        #ff2a6d,
        #ffc857,
        #33ffcc
      );
      background-size: 200% 100%;
      animation: slide 2600ms linear infinite;
    }

    @keyframes slide {
      0% {
        transform: translateX(-60%);
        background-position: 0% 50%;
      }
      100% {
        transform: translateX(60%);
        background-position: 100% 50%;
      }
    }

    .hint {
      font-size: 10px;
      opacity: 0.6;
      color: rgba(211, 219, 255, 0.8);
    }

    .hint strong {
      font-weight: 600;
      color: var(--accent1);
    }

    .overlay-vignette {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at top, transparent 0, rgba(0, 0, 0, 0.3) 70%),
        radial-gradient(circle at bottom, transparent 0, rgba(0, 0, 0, 0.7) 75%);
      mix-blend-mode: multiply;
      pointer-events: none;
      z-index: 2;
    }

    .scanline {
      position: absolute;
      inset: 0;
      background-image: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.05) 1px,
        transparent 1px
      );
      background-size: 100% 2px;
      opacity: 0.18;
      mix-blend-mode: soft-light;
      pointer-events: none;
      z-index: 1;
    }

    .corner {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 16px;
      border: 1px solid rgba(103, 115, 255, 0.5);
      opacity: 0.22;
      pointer-events: none;
    }

    .corner.tl {
      top: 18px;
      left: 32px;
      border-right: none;
      border-bottom: none;
    }

    .corner.tr {
      top: 18px;
      right: 32px;
      border-left: none;
      border-bottom: none;
    }

    .corner.bl {
      bottom: 80px;
      left: 32px;
      border-right: none;
      border-top: none;
    }

    .corner.br {
      bottom: 80px;
      right: 32px;
      border-left: none;
      border-top: none;
    }

    @media (max-width: 720px) {
      header {
        top: 12px;
      }

      header h1 {
        font-size: 11px;
        letter-spacing: 0.28em;
      }

      .controls {
        flex-direction: column;
        align-items: flex-start;
        padding: 14px 16px 18px;
        gap: 10px;
      }

      .right {
        width: 100%;
        justify-content: space-between;
      }

      .bar {
        width: 90px;
      }

      .corner.tl,
      .corner.tr {
        top: 40px;
      }

      .corner.bl,
      .corner.br {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1><span>AUDIO</span> REACTIVE GRIDSPACE</h1>
    </header>

    <main>
      <section class="scene">
        <canvas id="viz"></canvas>

        <div class="overlay-vignette"></div>
        <div class="scanline"></div>
        <div class="corner tl"></div>
        <div class="corner tr"></div>
        <div class="corner bl"></div>
        <div class="corner br"></div>
      </section>

      <section class="controls">
        <div class="left">
          <div class="glow-dot"></div>
          <div class="indicator-text">
            LIVE INPUT <span>LISTENING</span>
          </div>
          <div class="button-row">
            <button id="start" class="btn">
              <span class="dot"></span>
              <span class="txt">Enable Mic</span>
            </button>
            <div class="modes">
              <span class="tiny-label">Mode</span>
              <div class="mode-pill active" data-mode="grid">Grid</div>
              <div class="mode-pill" data-mode="orbit">Orbit</div>
              <div class="mode-pill" data-mode="pulse">Pulse</div>
            </div>
          </div>
        </div>
        <div class="right">
          <div>
            <div class="tiny-label">Input level</div>
            <div class="bar">
              <div class="bar-fill" id="levelFill"></div>
            </div>
          </div>
          <div class="hint">
            allow mic, then play anything <strong>loud</strong>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    const canvas = document.getElementById("viz");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("start");
    const modePills = document.querySelectorAll(".mode-pill");
    const levelFill = document.getElementById("levelFill");

    let audioCtx;
    let analyser;
    let dataArray;
    let running = false;
    let currentMode = "grid";
    let smoothedLevel = 0;

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener("resize", resize);
    resize();

    modePills.forEach((pill) => {
      pill.addEventListener("click", () => {
        modePills.forEach((p) => p.classList.remove("active"));
        pill.classList.add("active");
        currentMode = pill.getAttribute("data-mode");
      });
    });

    async function setupAudio() {
      if (running) return;
      running = true;

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.8;

        const source = audioCtx.createMediaStreamSource(stream);
        source.connect(analyser);

        dataArray = new Uint8Array(analyser.frequencyBinCount);

        startBtn.querySelector(".txt").textContent = "Listening";
        draw();
      } catch (err) {
        console.error(err);
        startBtn.querySelector(".txt").textContent = "Mic blocked";
      }
    }

    startBtn.addEventListener("click", setupAudio);

    function getAudioLevel() {
      if (!analyser) return 0;
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const avg = sum / dataArray.length;
      return avg / 255;
    }

    function drawGrid(level, time) {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      const cx = w / 2;
      const cy = h * 0.65;
      const gridDepth = 26;
      const baseSpacing = 18;
      const perspective = 260;
      const wave = Math.sin(time * 0.0018) * 0.5 + 0.5;
      const intensity = 0.2 + level * 1.1;

      const bgGrad = ctx.createRadialGradient(
        cx,
        h * 0.1,
        10,
        cx,
        h * 0.5,
        h * 1.1
      );
      bgGrad.addColorStop(0, "rgba(84, 115, 255, 0.85)");
      bgGrad.addColorStop(0.32, "rgba(15, 24, 68, 0.9)");
      bgGrad.addColorStop(1, "rgba(0, 0, 0, 1)");
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, w, h);

      const horizonY = h * 0.32 + wave * 10 * (0.3 + level);
      const glow = ctx.createLinearGradient(0, horizonY - 40, 0, horizonY + 60);
      glow.addColorStop(0, "rgba(51, 255, 204, 0)");
      glow.addColorStop(0.45, `rgba(51, 255, 204, ${0.35 + level * 0.5})`);
      glow.addColorStop(1, "rgba(255, 42, 109, 0)");
      ctx.fillStyle = glow;
      ctx.fillRect(0, horizonY - 40, w, 100);

      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = `rgba(51, 255, 204, ${0.16 + intensity * 0.3})`;

      for (let i = 0; i < gridDepth; i++) {
        const depth = i / gridDepth;
        const z = depth * perspective;
        const perspectiveScale = 1 / (1 + z * 0.022);
        const y =
          horizonY +
          depth * h * 0.7 +
          Math.sin(depth * 8 + time * 0.003 + level * 6) * (10 + level * 60);

        const colorBlend = 0.3 + depth * 0.4 + level * 0.3;
        const r = 51 + (255 - 51) * depth;
        const g = 255 - 60 * depth;
        const b = 204 + (109 - 204) * depth;

        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${colorBlend * 0.7})`;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();

        if (i % 3 === 0) {
          ctx.save();
          ctx.strokeStyle = `rgba(120, 132, 255, ${0.2 + intensity * 0.4})`;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.stroke();
          ctx.restore();
        }

        const cols = 28;
        for (let x = 0; x <= cols; x++) {
          const t = (x / cols - 0.5) * 2;
          const px = cx + t * w * 0.7 * perspectiveScale;
          const py = y;

          const pulse =
            Math.max(
              0,
              Math.sin(time * 0.004 + t * 7 + level * 8 + depth * 8)
            ) * intensity;
          const sz = 2 + pulse * 4 + depth * 2;
          const alpha = 0.12 + depth * 0.3 + level * 0.5;

          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.beginPath();
          ctx.arc(px, py, sz, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.restore();

      const centreGlowRadius = 170 + level * 220;
      const centreGlow = ctx.createRadialGradient(
        cx,
        horizonY,
        0,
        cx,
        horizonY,
        centreGlowRadius
      );
      centreGlow.addColorStop(0, `rgba(51, 255, 204, ${0.35 + level * 0.7})`);
      centreGlow.addColorStop(0.4, `rgba(109, 93, 255, ${0.24 + level * 0.6})`);
      centreGlow.addColorStop(1, "rgba(0, 0, 0, 0)");

      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = centreGlow;
      ctx.beginPath();
      ctx.arc(cx, horizonY, centreGlowRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";
    }

    function drawOrbit(level, time) {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      const cx = w / 2;
      const cy = h / 2;

      const bg = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h));
      bg.addColorStop(0, `rgba(5, 10, 35, 1)`);
      bg.addColorStop(1, `rgba(0, 0, 0, 1)`);
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, w, h);

      const rings = 9;
      for (let i = 0; i < rings; i++) {
        const t = i / rings;
        const baseRadius =
          60 + t * Math.min(w, h) * 0.55 + Math.sin(time * 0.001 + t * 5) * 4;
        const jitter = level * 35 * (0.5 + t);
        const r = baseRadius + jitter;

        const alpha = 0.12 + t * 0.4 + level * 0.45;
        const lineWidth = 1 + t * 1.5 + level * 1.4;

        const hue = 180 + t * 120 + level * 70;
        ctx.strokeStyle = `hsla(${hue}, 95%, 65%, ${alpha})`;
        ctx.lineWidth = lineWidth;

        ctx.beginPath();
        const wobble =
          0.18 + level * 0.7 + (Math.sin(time * 0.0015 + t * 4) * 0.2);
        for (let a = 0; a <= Math.PI * 2; a += 0.04) {
          const offset =
            Math.sin(a * 4 + time * 0.002 + t * 8) * wobble * 18;
          const radius = r + offset;
          const x = cx + Math.cos(a) * radius;
          const y = cy + Math.sin(a) * radius * (0.7 + t * 0.1);
          if (a === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      const particles = 220;
      ctx.globalCompositeOperation = "screen";
      for (let i = 0; i < particles; i++) {
        const t = i / particles;
        const baseRadius = 40 + t * Math.min(w, h) * 0.46;
        const mod = Math.sin(time * 0.0013 + t * 10 + level * 12);
        const radius = baseRadius + mod * 28 * (0.4 + level);

        const angle =
          time * 0.0006 * (1 + t * 2) +
          t * Math.PI * 6 +
          level * 3 +
          i * 0.12;
        const x = cx + Math.cos(angle) * radius;
        const y = cy + Math.sin(angle) * radius * 0.9;

        const pulse = Math.max(0, mod) * (0.4 + level * 0.9);
        const size = 1 + pulse * 4;
        const alpha = 0.2 + pulse * 0.8;

        const hue = 170 + t * 120;
        ctx.fillStyle = `hsla(${hue}, 96%, 64%, ${alpha})`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalCompositeOperation = "source-over";

      const corePulse = 1 + level * 1.4 + Math.sin(time * 0.008) * 0.3;
      const inner = ctx.createRadialGradient(cx, cy, 0, cx, cy, 80 * corePulse);
      inner.addColorStop(0, `rgba(255, 255, 255, ${0.4 + level * 0.4})`);
      inner.addColorStop(0.35, `rgba(51, 255, 204, ${0.6 + level * 0.5})`);
      inner.addColorStop(0.7, `rgba(109, 93, 255, ${0.4 + level * 0.3})`);
      inner.addColorStop(1, "rgba(0, 0, 0, 0)");

      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = inner;
      ctx.beginPath();
      ctx.arc(cx, cy, 80 * corePulse, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";
    }

    function drawPulse(level, time) {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      const bg = ctx.createLinearGradient(0, 0, 0, h);
      bg.addColorStop(0, "rgba(10, 5, 35, 1)");
      bg.addColorStop(0.5, "rgba(3, 5, 20, 1)");
      bg.addColorStop(1, "rgba(0, 0, 0, 1)");
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, w, h);

      const rows = 5;
      const cols = 90;

      const baseY = h / 2;
      ctx.globalCompositeOperation = "screen";

      for (let r = 0; r < rows; r++) {
        const rowT = r / (rows - 1 || 1);
        for (let i = 0; i < cols; i++) {
          const t = i / (cols - 1 || 1);
          const x = t * w;

          const freqWarp = Math.sin(t * 12 + rowT * 4 + time * 0.003);
          const beat = Math.sin(time * 0.01 + rowT * 1.6);
          const displace =
            freqWarp * 28 * (0.3 + level) + beat * 40 * (0.2 + level * 0.8);

          const y =
            baseY +
            (rowT - 0.5) * 80 +
            displace +
            Math.sin(t * 40 + time * 0.018) * 6 * (0.2 + level);

          const intensity =
            0.25 +
            Math.pow(Math.max(0, Math.cos(t * Math.PI * 2)), 2.2) *
              (0.4 + level) +
            level * 0.8;

          const size = 1.2 + intensity * 3;
          const hue = 170 + t * 160 + rowT * 40 * (1 + level);
          const alpha = 0.1 + intensity * 0.7;

          ctx.fillStyle = `hsla(${hue}, 96%, 60%, ${alpha})`;
          ctx.beginPath();
          ctx.roundRect(x - size / 2, y - size * 2.4, size, size * 4.3, 999);
          ctx.fill();
        }
      }

      ctx.globalCompositeOperation = "source-over";

      const overlayGrad = ctx.createLinearGradient(0, 0, 0, h);
      overlayGrad.addColorStop(
        0,
        `rgba(51, 255, 204, ${0.18 + level * 0.3})`
      );
      overlayGrad.addColorStop(0.3, "rgba(0, 0, 0, 0)");
      overlayGrad.addColorStop(0.7, "rgba(0, 0, 0, 0)");
      overlayGrad.addColorStop(
        1,
        `rgba(255, 42, 109, ${0.16 + level * 0.3})`
      );
      ctx.fillStyle = overlayGrad;
      ctx.fillRect(0, 0, w, h);
    }

    function updateLevelBar(level) {
      const pct = 6 + level * 88;
      levelFill.style.width = pct + "%";
    }

    function draw(time) {
      requestAnimationFrame(draw);
      const rawLevel = getAudioLevel();
      smoothedLevel = smoothedLevel * 0.9 + rawLevel * 0.1;
      const level = Math.min(1, smoothedLevel * 1.7);

      updateLevelBar(level);

      switch (currentMode) {
        case "grid":
          drawGrid(level, time);
          break;
        case "orbit":
          drawOrbit(level, time);
          break;
        case "pulse":
          drawPulse(level, time);
          break;
      }
    }

    draw(performance.now());
  </script>
</body>
</html>